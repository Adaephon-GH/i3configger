import logging
import socket
import time
from pathlib import Path
from string import Template

import re

from i3configger import util

log = logging.getLogger(__name__)
HOSTNAME = socket.gethostname()


class I3Configger:
    SOURCES_PATH = Path('~/.i3/config.d').expanduser()
    TARGET_PATH = Path('~/.i3/config').expanduser()
    SOURCE_SUFFIX = '.conf'

    def __init__(self, sourcePath=SOURCES_PATH, targetPath=TARGET_PATH):
        self.sourcePath = sourcePath
        self.configTargetPath = targetPath

    def build(self):
        self.prepare()
        self.build_main_config()
        self.build_i3status()

    def prepare(self):
        mainPaths = self.get_file_paths(
            self.sourcePath,
            # TODO these can be set and read as i3configger settings
            filters=(('host', HOSTNAME), )
        )
        self.mainContent = self.get_contents(mainPaths)
        vars_ = self.parse(self.mainContent)
        resolvedVars_ = self.resolve(vars_)
        self.vars = self.clean(vars_)

        # TODO this looks like a two pass thing
        filters = self.fetch_settings('filter', self.vars)
        additionalPaths = self.get_file_paths(
            self.sourcePath, filters=[(k, v) for k, v in filters.items()])
        self.additionalContent = self.get_contents(additionalPaths)
        vars_ = self.parse(self.additionalContent)
        resolvedVars_ = self.resolve(vars_)
        cleanVars = self.clean(vars_)
        self.vars.update(cleanVars)

        # TODO prune all (now unnecessary) set statements from mainContent


    def build_main_config(self):
        self.render_config(
            self.mainContent, self.vars, self.configTargetPath)

    def build_i3status(self):
        settings = self.fetch_settings(
            'i3status', self.vars)
        for bar, target in settings.items():
            targetPath = Path(target).expanduser()
            srcPath = self.sourcePath / targetPath.name
            content = self.get_contents(srcPath)
            self.render_config(content, self.vars, targetPath)

    @classmethod
    def render_config(cls, content, vars_, targetPath):
        # configTargetPath.chmod(0o644)
        tpl = Template(content)
        renderedContent = tpl.safe_substitute(vars_)
        log.debug('\n' + ''.join(renderedContent))
        targetPath.write_text(''.join(renderedContent))
        # configTargetPath.chmod(0o444)

    @staticmethod
    def fetch_settings(marker, vars_):
        """Simple way of communicating settings to i3configger

        $i3configger_somecommonsetting_keyname value
        $i3configger_somecommonsetting_otherkeyname othervalue

        will be turned into ...
        
        dict(keyname=value, otherkeyname=othervalue)
        """
        marker = 'i3configger_' + marker + '_'
        markerLen = len(marker)
        return {k[markerLen:]: v for k, v in vars_.items()
                if k.startswith(marker)}

    def get_file_paths(self, sourcePath, filters=None):
        """:returns: list of pathlib.Path"""
        filePaths = []
        for sp in [p for p in self.sourcePath.iterdir()]:
            if not sp.is_file():
                continue
            if sp.suffix != self.SOURCE_SUFFIX:
                continue
            parts = sp.stem.split('.')
            if len(parts) > 1 and filters:
                criterion, spec, *_ = parts
                for wanted, value in filters:
                    if criterion == wanted:
                        if ((isinstance(spec, str) and spec == value)
                                or spec in value):
                            filePaths.append(sp)
            else:
                filePaths.append(sp)
        return sorted(filePaths)

    @staticmethod
    def resolve(vars_):
        resolvedVars = vars_.copy()
        """resolve values that are vars_ (e.g. set $var $ otherVar)"""
        for key, value in resolvedVars.items():
            if value.startswith('$'):
                try:
                    resolvedVars[key] = resolvedVars[value]
                except KeyError:
                    log.exception("[IGNORED] %s, %s", key, value)
        return resolvedVars

    @staticmethod
    def get_contents(pathOrPaths):
        paths = [pathOrPaths] if isinstance(pathOrPaths, Path) else pathOrPaths
        msg = '# generated by i3configger (%s) #' % (time.asctime())
        sep = "#" * len(msg)
        out = ["%s\n%s\n%s\n" % (sep, msg, sep)]
        for filePath in paths:
            content = filePath.read_text()
            content = "### %s ###\n%s\n" % (filePath.name, content)
            out.append(content)
        return ''.join(out)

    @classmethod
    def parse(cls, content):
        """read all set commands"""
        vars_ = {}
        for line in [l.strip() for l in content.splitlines(keepends=False)]:
            if cls.looks_like_assignment(line):
                key, value = cls.get_assignment(line)
                vars_[key] = value
        return vars_

    @staticmethod
    def looks_like_assignment(line):
        return line.startswith('set ')

    ASSIGNMENT_RE = re.compile(r'(\$\S+)\s+(.*)')

    @classmethod
    def get_assignment(cls, line):
        sanitizedLine = (line.split('set')[1].split(' # ')[0]).strip()
        if len([c for c in sanitizedLine if c == '#']) > 1:
            raise MalformedAssignment("comments need space: '%s'", line)
        match = re.match(cls.ASSIGNMENT_RE, sanitizedLine)
        if not match or len(match.groups()) != 2:
            raise MalformedAssignment("can't match properly: '%s'", line)
        return match.group(1), match.group(2)

    @staticmethod
    def clean(vars_):
        return {key[1:]: value for key, value in vars_.items()}


class MalformedAssignment(Exception):
    pass


if __name__ == '__main__':
    util.configure_logging(3)
    configger = I3Configger(types=('solarized-dark', 'solarized-vars'))
    configger.build()
    util.IpcControl.restart_i3()
    assert True
