import logging
import pprint
import time
from pathlib import Path
from string import Template

from i3configger import defaults

log = logging.getLogger(__name__)


class I3Configger:
    def __init__(self,
                 sourcePath=defaults.SOURCES_PATH,
                 targetPath=defaults.TARGET_PATH,
                 suffix=defaults.SOURCE_SUFFIX,
                 selectors=None, statusMarker=None):
        self.sourcePath = sourcePath
        self.mainTargetPath = targetPath
        self.suffix = suffix
        self.selectors = selectors or []
        self.statusMarker = statusMarker
        log.info("initialized %s", self)

    def __str__(self):
        return "%s(%s)" % (
            self.__class__.__name__, pprint.pformat(self.__dict__))

    def build(self):
        self.build_main_config()
        self.build_i3status()

    def build_main_config(self):
        """two pass rendering to figure out from content what"""
        # fixme this statusmarker special case is ugly, get rid of it
        paths = get_file_paths(
            self.sourcePath, self.suffix,
            selectors=self.selectors + [[self.statusMarker, None]])
        self.content = self.get_content(paths)
        self.vars = render_vars(self.content)
        config = self.render_config(self.content, self.vars)
        self.mainTargetPath.write_text(config)

    # TODO extract this to it's own class with own handling
    def build_i3status(self):
        settings = self.fetch_settings('i3status', self.vars)
        for _, target in settings.items():
            targetPath = Path(target).expanduser()
            srcPath = self.sourcePath / targetPath.name
            content = self.get_content(srcPath)
            status = self.render_config(content, self.vars)
            targetPath.write_text(status)

    @classmethod
    def render_config(cls, content, vars_):
        """Works out of the box, because $ is the standard substitution marker
        for string.Template"""
        tpl = Template(content)
        renderedContent = tpl.safe_substitute(vars_)
        return renderedContent

    @staticmethod
    def fetch_settings(marker, vars_):
        """Simple way of communicating settings to i3configger

        $i3configger_somecommonsetting_keyname value
        $i3configger_somecommonsetting_otherkeyname othervalue

        will be turned into ...

        dict(keyname=value, otherkeyname=othervalue)
        """
        marker = 'i3configger_' + marker + '_'
        markerLen = len(marker)
        return {k[markerLen:]: v for k, v in vars_.items()
                if k.startswith(marker)}

    @staticmethod
    def get_content(pathOrPaths):
        paths = [pathOrPaths] if isinstance(pathOrPaths, Path) else pathOrPaths
        msg = '# generated by i3configger (%s) #' % (time.asctime())
        sep = "#" * len(msg)
        out = ["%s\n%s\n%s\n" % (sep, msg, sep)]
        for filePath in paths:
            content = filePath.read_text()
            content = "### %s ###\n%s\n" % (filePath.name, content)
            out.append(content)
        return ''.join(out)
